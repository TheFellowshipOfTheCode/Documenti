\section{Processo di sviluppo}

\subsection{Scopo del processo}

\subsection{Analisi dei Requisiti}
\subsubsection{Studio di Fattibilità}
Alla pubblicazione dei capitolati d'appalto il \textsl{\RdP} dovrà fissare un 
numero di riunioni volte alla discussione e al confronto tra i membri del team. 
In seguito, gli \textsl{Analisti} dovranno redigere lo \textsl{\SdF} in base a quanto 
emerso nelle riunioni.\\
Lo \textsl{\SdF} sarà articolato nei seguenti punti:
\begin{itemize}
  \item \textbf{Descrizione:} descrizione generale di ciò che viene richiesto 
  dal capitolato;
  \item \textbf{Dominio Applicativo:} descrizione dell'ambito di utilizzo del 
  prodotto richiesto;
  \item \textbf{Dominio Tecnologico:} descrizione delle tecnologie impiegate 
  nello sviluppo del progetto richiesto;
  \item \textbf{Criticità:} elenco delle possibili problematiche che potrebbero 
  sorgere durante lo sviluppo del prodotto richiesto, individuando quindi punti 
  critici ed eventuali rischi;
  \item \textbf{Valutazione Finale:} piccolo riassunto finale nel quale verranno 
  spiegate le motivazioni per cui è stato scelto o scartato il suddetto 
  capitolato.
\end{itemize}

\subsubsection{Analisi dei Requisiti}
Ultimato lo \textsl{\SdF} gli \textsl{Analisti} dovranno redigere l'\textsl{\AdR} 
che dovrà obbligatoriamente essere strutturata nel seguente modo:

\paragraph{Classificazione dei requisiti}
Dovrà essere redatto un elenco di requisiti, emersi durante le riunioni interne 
e/o esterne. Questo compito spetta agli \textsl{Analisti}. I requisiti dovranno 
essere classificati secondo la seguente codifica:
R[Tipo][Importante][Codice]

\begin{itemize} 
  \item \textbf{Tipo:} può assumere questi valori:
  \begin{itemize}
    \item \textbf{F:} indica un requisito funzionale;
    \item \textbf{Q:} indica un requisito di qualità;
    \item \textbf{P:} indica un requisito prestazionale;
    \item \textbf{V:} indica un requisito di vincolo.
  \end{itemize}
  \item \textbf{Importanza:} può assumere questi valori:
  \begin{itemize}
    \item \textbf{O:} indica un requisito obbligatorio;
    \item \textbf{D:} indica un requisito desiderabile;
    \item \textbf{F:} indica un requisito facoltativo.
  \end{itemize}
  \item \textbf{Codice:} indica il codice identificativo del requisito, è 
  univoco e deve essere indicato in forma gerarchica.
\end{itemize}
Per ogni requisito si dovrà inoltre indicare: 
\begin{itemize}
  \item \textbf{Descrizione:} una breve descrizione, deve essere meno ambigua possibile;
  \item \textbf{Fonte:} la fonte può essere una delle seguenti:
  \begin{itemize}
    \item \textsl{Capitolato:} deriva direttamente dal testo del capitolato;
    \item \textsl{Verbale:} deriva da un incontro verbalizzato;
    \item \textsl{Interno:} deriva da discussioni interne al team;
    \item \textsl{Casi d'uso:} deriva da uno o più casi d'uso.
  \end{itemize}
\end{itemize} 
\paragraph{Classificazione dei casi d'uso}
Lo scopo del documento e quello di descrivere le motivazioni che hanno portato il gruppo alla scelta del capitolato C5.
Verranno inoltre riportate le descrizioni di tutti gli altri capitolati e le motivazioni che hanno spinto il gruppo a scartarli.

\subsubsection{Tracciamento}
Gli \textsl{Analisti} hanno il compito di inserire tutti i requisiti e i casi d'uso in \textsl{DocumentsDB},
software concesso dal gruppo \textsl{PragmaDB}, appositamente modificato da alcuni membri del 
team, che permette la gestione automatica della tracciabilità degli elementi inseriti. 
Inoltre i requisiti verranno inseriti in formato tabellare nel documento di \textsl{\AdR}.
\subsection{Progettazione}


\subsubsection{Descrizione}
L'attività di progettazione definisce come deve essere realizzata la struttura dell'architettura software. I requisiti delineati, all'interno del documento Analisi dei Requisiti, devono essere utili a realizzare la documentazione specifica e a determinare le linee guida da seguire durante l'attività di codifica. 
Tale attività deve essere svolta in maniera ottimale e precisa dai progettisti.  
  
\subsubsection{Diagrammi}
La progettazione deve utilizzare le seguenti tipologie di diagrammi UML\ped{G}:
\begin{itemize} 
\item
\textbf{Diagrammi di classi}: illustra una collezione di elementi dichiarativi di un modello come classi e tipi, assieme ai loro contenuti e alle loro relazioni;  
\item
\textbf{Diagrammi dei package}\ped{G}: raggruppamenti di classi in una unità di livello più alto;
\item
\textbf{Diagrammi di attività}: illustra il flusso di operazioni relativo ad un'attività; utilizzati soprattutto per descrivere la logica di un algoritmo;  
\item
\textbf{Diagrammi di sequenza}: descrive una determinata sequenza di azioni dove tutte le scelte sono già state effettuate; in pratica nel diagramma non compaiono scelte, né flussi alternativi.
\end{itemize}


\subsubsection{Requisiti per i progettisti}

I progettisti sono responsabili delle attività di progettazione. Essi sono tenuti ad avere:
\begin{itemize} 
\item
Profonda conoscenza di tutto ciò che riguarda il processo di sviluppo del software;
\item
Capacità di saper anticipare i cambiamenti;
\item
Notevole inventiva per riuscire a trovare una soluzione progettuale accettabile anche in mancanza di una metodologia che sia sufficientemente espressiva;
\item
Capacità di individuare con rapidità e sicurezza le soluzioni più opportune.
\end{itemize}

\subsubsection{Obiettivi della progettazione}
La fase di progettazione si pone i seguenti obiettivi:
\begin{itemize} 
\item
Progettare un software con le caratteristiche di qualità che sono state dettagliate nella fase di analisi e specifica dei requisiti;
\item
Capacità di poter far fronte a modifiche da effettuare senza che l'intera struttura del software già costruita debba essere messa nuovamente in discussione ed elaborata;
\item
Soddisfare i requisiti di qualità fissati dal committente.
\end{itemize}

\subsubsection{Tracciamento}
Ogni requisito deve essere tracciato all'interno del documentsDB, software
appositamente creato da alcuni componenti del gruppo che permette la tracciabilità e la classificazione automatica degli elementi inseriti.

\subsection{Codifica}

\subsubsection{Descrizione}
L'attività di codifica ha come obiettivo passare dalla descrizione della soluzione in termini di architettura alla descrizione della soluzione in formato eseguibile da un calcolatore. I programmatori, responsabili di questa attività, sono tenuti a seguire le linee guida, delineate nell'attività di progettazione, con lo scopo di produrre in output il software designato. 

\subsubsection{Standard di Codifica}
\paragraph{Descrizione}
Affinché questa attività sia svolta al meglio, è opportuno che i programmatori rispettino uno standard di codifica.
Esso rappresenta uno strumento fondamentale per garantire sintonia tra gli sviluppatori e la creazione di un codice sorgente uniforme e valido.
All'interno dello standard di codifica è necessario definire le modalità di scrittura e gestione del codice sorgente, al fine di facilitare la modifica del sistema software.
L'utilizzo di tecniche di scrittura del codice affidabili e di regole di programmazione valide per la creazione di codice di alta qualità è di fondamentale importanza per le prestazioni e la qualità del software. 


\paragraph{Tecniche di Scrittura}
La definizione di tecniche di scrittura è importante per avere una maggiore comprensione del codice sorgente.
Le tecniche di scrittura del codice sono suddivise in tre categorie:
\begin{itemize} 
\item
\textbf{Nomi}
\item
\textbf{Commenti}
\item
\textbf{Formattazione}
\end{itemize}

\subparagraph{Nomi}
Lo schema di denominazione rappresenta uno dei supporti più determinanti per la comprensione del flusso logico del software. 
Di seguito sono riportate le tecniche di denominazione raccomandate:
\begin{itemize} 
\item
Assegnare ad ogni elemento un nome univoco e consono alla funzione svolta; 
\item
Evitare nomi poco chiari e suscettibili di interpretazioni soggettive; questo tipo di nome può contribuire a creare ambiguità piuttosto che astrazione;
\item
Utilizzare la struttura verbo - nome per la denominazione di routine che consentono di eseguire operazioni specifiche su determinati oggetti;
\item
Poiché la maggior parte dei nomi viene creata concatenando più parole, utilizzare una combinazione di caratteri maiuscoli e minuscoli per semplificarne la lettura;
\item
Utilizzare un nome significativo anche per le variabili che vengono visualizzate solo in poche righe di codice;
\item
Utilizzare nomi di variabili composti da una singola lettera, come i o j, esclusivamente per gli indici a ciclo breve;
\item
Ridurre l'utilizzo delle abbreviazioni ma utilizzare quelle create in maniera coerente. È opportuno che a ogni abbreviazione corrisponda un solo significato e che a ciascuna parola abbreviata sia associata una sola abbreviazione. Se, ad esempio, si utilizza min come abbreviazione di minimum, in altri contesti non è possibile utilizzare la stessa abbreviazione per minute;
\item
Nella denominazione di funzioni inserire una descrizione del valore restituito;
\item
Evitare di utilizzare gli stessi nomi per elementi diversi, ad esempio una routine e una variabile denominate rispettivamente Getname() e iGetname;
\item
Nella denominazione degli elementi non utilizzare omonimi per evitare ambiguità durante le revisioni del codice;
\item
Per la denominazione degli elementi evitare l'uso di parole ortograficamente errate;
\item
È opportuno che nei nomi di file e cartelle sia contenuta una descrizione precisa della relativa funzione.
\end{itemize}


\subparagraph{Commenti}
All'interno del codice sorgente è di fondamentale importanza l'inserimento di commenti al fine di facilitare la comprensione del flusso logico.
Di seguito sono suggeriti alcuni metodi di inserimento dei commenti:
\begin{itemize}
\item
Quando si modifica il codice mantenere sempre aggiornati i relativi commenti;
\item
All'inizio di ogni routine è utile fornire commenti predefiniti standard in cui siano indicati le limitazioni, i presupposti e lo scopo della routine. Per commento predefinito si intende una breve introduzione in cui siano illustrate le funzionalità della routine;
\item
Evitare l'aggiunta di commenti alla fine di una riga di codice; la presenza di commenti a fine riga può rendere più difficoltosa la lettura del codice. Tuttavia questo tipo di commento è valido per l'annotazione di dichiarazioni di variabili. In tal caso è necessario allineare tutti i commenti di fine riga a una tabulazione comune;
\item
Evitare commenti confusi come righe intere di asterischi. Utilizzare invece spazi vuoti per separare i commenti dal codice;
\item
Evitare di racchiudere blocchi di commenti in cornici grafiche. Si tratta di un espediente interessante ma di difficile gestione;
\item
Quando si scrivono commenti, utilizzare frasi di senso compiuto. La funzione dei commenti consiste nel chiarire il significato del codice senza aggiungere alcun tipo di ambiguità;
\item
Inserire commenti in fase di scrittura del codice, in quanto ciò potrebbe non essere possibile in un secondo momento. Inoltre, se dovesse presentarsi l'opportunità di rivedere il codice scritto, tenere presente che ciò che può essere evidente al momento della stesura potrebbe non esserlo più in futuro;
\item
Evitare commenti superflui o inappropriati, come annotazioni umoristiche;
\item
Commentare tutto ciò che non è chiaro nel codice;
\item
Per evitare problemi ricorrenti, è opportuno utilizzare sempre i commenti nel caso di codice relativo a correzioni di errori e a potenziali soluzioni;
\item
Aggiungere commenti al codice costituito da cicli e diramazioni logiche. Si tratta di aree di fondamentale importanza che facilitano la lettura del codice sorgente;
\item
Creare commenti adottando uno stile uniforme e una struttura e una punteggiatura coerenti;
\item
Separare i commenti dai delimitatori di commento con spazi vuoti. In questo modo i commenti saranno chiari e facili da individuare.
\end{itemize}

\subparagraph{Formattazione}
La formattazione facilita la comprensione dell'organizzazione logica del codice. Per consentire agli sviluppatori la decifrazione del codice sorgente è fondamentale una formattazione logica e coerente.

Di seguito sono suggeriti alcuni metodi di formattazione:
\begin{itemize}
\item
Definire una dimensione standard per i rientri e utilizzarla in maniera coerente. Allineare le sezioni di codice utilizzando il rientro predefinito;
\item
Allineare in verticale le parentesi di apertura e chiusura in cui esistono coppie di parentesi allineate. È possibile inoltre utilizzare uno stile trasversale, laddove le parentesi di apertura si trovano alla fine della riga mentre quelle di chiusura all'inizio. Qualunque sia lo stile scelto, utilizzarlo in tutto il codice sorgente;
\item
Rientrare le righe di codice secondo la relativa costruzione logica. Se non viene utilizzato il rientro, il codice risulterà di difficile comprensione;
\item
Utilizzare spazi prima e dopo la maggior parte degli operatori, se ciò non altera la funzione del codice;
\item
Utilizzare spazi prima e dopo la maggior parte degli operatori, se ciò non altera la funzione del codice;
\item
Utilizzare spazi vuoti per definire la struttura del codice sorgente. In questo modo sarà possibile creare "paragrafi" di codice, che consentono di semplificare la comprensione della segmentazione logica del software da parte del lettore;
\item
Suddividere logicamente il codice sorgente tra diversi file fisici;
\item
Suddividere le sezioni complesse ed estese di codice in moduli comprensibili di dimensioni minori.
\end{itemize}

\subsubsection{Ricorsione}
La ricorsione va evitata quando possibile. Per ogni funzione ricorsiva sarà necessario fornire una prova di terminazione e sarà necessario valutare il costo in termini di occupazione della memoria. Nel caso l'utilizzo di memoria risulti troppo elevato la ricorsione verrà rimossa.

\subsection{Strumenti}

\subsubsection{DocumentsDB}(Da modificare)
Al fine di gestire in maniera veloce e il più possibile automatizzata tutti i dati e per semplificare i tracciamenti, il team ha creato un applicativo web: DocumentsDB.
DocumentsDB permette la gestione di casi d’uso, attori, fonti, requisiti e termini del Glossario. Ogni membro del team\ped{G} può accedervi via browser previa autenticazione, inoltre più persone possono lavorare simultaneamente sugli stessi dati poiché è stata gestita la concorrenza. L’applicazione si occupa di mantenere ordinata la gerarchia dei requisiti e degli UC in modo automatico durante tutto il suo ciclo di vita (creazione, modifica, eliminazione).
Vengono eseguiti diversi controlli su ciascun campo dati, e tale approccio garantisce fault-tolerance\ped{G} del sistema nei confronti di qualsiasi input possibile. I membri del gruppo possono visualizzare, inserire, modificare ed eliminare elementi in modo semplice. PragmaDB consente di esportare l’elenco degli attori, delle fonti, del Glossario, dei casi d’uso, dei requisiti e delle loro relazioni come codice \LaTeX\ped{G}, quindi facilmente inseribile all’interno dei documenti durante la stesura. Infine consente di visualizzare,
attraverso un menù laterale l’insieme dei link utili relativi al gruppo.

\subsubsection{Tracciabilità}
La Tracciabilità dei requisiti e dei casi d'uso avviene tramite l'utilizzo del software DocumentsDB, il quale da la possibilità ad ogni membro del team di inserire, modificare o eliminare requisiti o casi d'uso. Inoltre è utilizzato per tenere traccia dello stato dei requisiti, ovvero se sono stati soddisfatti o meno.

\subsubsection{TexMaker}
L'editor scelto dal team per sviluppare i documenti in \LaTex\ped{G} è Texmaker\ped{G}.  
TexMaker è un editor gratuito, moderno e multi-piattaforma per Linux\ped{G}, sistemi Mac OS\ped{G} e Microsoft Windows\ped{G} che integra molti strumenti utili per sviluppare documenti in \LaTeX\ped{G}.
TexMaker\ped{G} include il supporto Unicode\ped{G}, il controllo ortografico, il completamento automatico, il raggruppamento del codice e un visore incorporato pdf\ped{G} con il supporto SyncTex\ped{G} e modalità di visualizzazione continua.
TexMaker\ped{G} è uno strumento facile da usare e da configurare.


\subsubsection{WebStorm}
L'ambiente di sviluppo integrato (IDE\ped{G}) utilizzato è WebStorm\ped{G}. Sono stati testati anche altri IDE\ped{G}, ma nessuno si è dimostrato all'altezza. Esso presenta le seguenti funzionalità:
\begin{itemize}
\item
Autocompletamento del codice JavaScript\ped{G}, HTML\ped{G} e CSS\ped{G};
\item
Autocompletamento per metodi, funzioni e frameworks\ped{G} esterni, utili per il progetto;
\item
Debugger\ped{G} JavaScript\ped{G};
\item
Consente di effettuare unit test per JavaScript\ped{G} mediante il framework\ped{G} Karma\ped{G};
\item
Compila automaticamente i file Sass\ped{G} in CSS\ped{G};
\item
Tiene traccia dei cambiamenti effettuati sui file, consentendo di visualizzare lo storico delle modifiche locali e ritornare a versioni precedenti in caso di modifiche o perdite accidentali.
\end{itemize}


\subsection{Tecnologie utilizzate}
\subsubsection{HTML5}
HTML5\ped{G} è un linguaggio di markup\ped{G} per la strutturazione delle pagine web, derivato dallo standard che definisce HTML\ped{G}.
Il termine rappresenta due concetti differenti:
\begin{itemize}
		\item
			Una nuova versione del linguaggio HTML\ped{G}, con nuovi elementi, attributi e comportamenti;
		\item
			Un più ampio insieme di tecnologie che permettono siti web e applicazioni più diversificate e potenti.
\end{itemize}
HTML5\ped{G} si presenta come un linguaggio pronto ad essere plasmato secondo le più recenti necessità, sia dal lato della strutturazione del contenuto che da quello dello sviluppo di vere e proprie applicazioni.
Questo linguaggio verrà utilizzato per sviluppare la parte client dell'applicativo.

\subsubsection{CSS3}
CSS3\ped{G} è un linguaggio utilizzato per definire la formattazione di documenti HTML\ped{G}, XHTML\ped{G} e XML\ped{G}.
Questo linguaggio istruisce un browser\ped{G}r su come il documento debba essere presentato all'utente, per esempio definendone la formattazione del testo, il posizionamento degli elementi rispetto a diversi media e device eccetera.
Questa tecnologia verrà utilizzata per arricchire l'aspetto visuale e la presentazione della parte client.

\subsubsection{JavaScript}
JavaScript\ped{G} è un linguaggio di scripting\ped{G} lato client\ped{G} per la creazione di effetti dinamici interattivi all'interno di una pagina Web. Esso è un linguaggio interpretato, cioè non esiste nessun compilatore, ma è direttamente il browser\ped{G}, tramite un apposito motore di scripting, che interpreta il linguaggio.
L'enorme diffusione di JavaScript\ped{G} è dovuta principalmente al fiorire di numerose librerie nate allo scopo di semplificare la programmazione sul browser, ma anche alla nascita di framework\ped{G} lato server\ped{G} e nel mondo mobile che lo supportano come linguaggio principale.
La parte dinamica dell'applicativo verrà sviluppata tramite l'utilizzo di questo linguaggio.

\subsubsection{Node.js}
Node.js\ped{G} è un framework\ped{G} relativo all'utilizzo lato server\ped{G} di JavaScript\ped{G}.
La caratteristica principale di Node.js\ped{G} risiede nella possibilità di accedere alle risorse del sistema operativo in modalità event-driven\ped{G} e non sfruttando il classico modello basato su processi o threads\ped{G} concorrenti, utilizzato dai classici web server.
Il modello event-driven\ped{G}, o "programmazione ad eventi", si basa su un concetto piuttosto semplice: si lancia una azione quando accade qualcosa. Ogni azione quindi risulta asincrona a differenza dei pattern di programmazione più comune in cui una azione succede ad un'altra solo dopo che essa è stata completata.
Tale modello di networking\ped{G} è ritenuto più efficiente nelle situazioni critiche in cui si verifica un elevato traffico di rete.
Node.js\ped{G} verrà utilizzato per sviluppare la parte server dell'applicativo.



