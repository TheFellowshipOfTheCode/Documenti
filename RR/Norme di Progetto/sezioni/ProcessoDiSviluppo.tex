\section{Processo di sviluppo}

\subsection{Scopo del processo}

\subsection{Analisi dei Requisiti}
\subsubsection{Studio di Fattibilità}
Alla pubblicazione dei capitolati d'appalto il \textsl{\RdP} dovrà fissare un 
numero di riunioni volte alla discussione e al confronto tra i membri del team. 
In seguito, gli \textsl{Analisti} dovranno redigere lo \textsl{\SdF} in base a quanto 
emerso nelle riunioni.\\
Lo \textsl{\SdF} sarà articolato nei seguenti punti:
\begin{itemize}
  \item \textbf{Descrizione:} Descrizione generale di ciò che viene richiesto 
  dal capitolato;
  \item \textbf{Dominio Applicativo:} Descrizione dell'ambito di utilizzo del 
  prodotto richiesto;
  \item \textbf{Dominio Tecnologico:} Descrizione delle tecnologie impiegate 
  nello sviluppo del progetto richiesto;
  \item \textbf{Criticità:} Elenco delle possibili problematiche che potrebbero 
  sorgere durante lo sviluppo del prodotto richiesto, individuando quindi punti 
  critici ed eventuali rischi;
  \item \textbf{Valutazione Finale:} Piccolo riassunto finale nel quale verranno 
  spiegate le motivazioni per cui è stato scelto o scartato il suddetto 
  capitolato.
\end{itemize}

\subsubsection{Analisi dei Requisiti}
Ultimato lo \textsl{\SdF} gli \textsl{Analisti} dovranno redigere l'\textsl{\AdR} 
che dovrà obbligatoriamente essere strutturati nel seguente modo:

\paragraph{Classificazione dei requisiti}
Dovrà essere redatto un elenco di requisiti, emersi durante le riunioni interne 
e/o esterne. Questo compito spetta agli \textsl{Analisti}. I requisiti dovranno 
essere classificati secondo la seguente codifica:
R[Tipo][Importante][Codice]

\begin{itemize} 
  \item \textbf{Tipo:} può assumere questi valori:
  \begin{itemize}
    \item \textbf{F:} indica un requisito funzionale;
    \item \textbf{Q:} indica un requisito di qualità;
    \item \textbf{P:} indica un requisito prestazionale;
    \item \textbf{V:} indica un requisito di vincolo.
  \end{itemize}
  \item \textbf{Importanza:} può assumere questi valori:
  \begin{itemize}
    \item \textbf{O:} indica un requisito obbligatorio;
    \item \textbf{D:} indica un requisito desiderabile;
    \item \textbf{F:} indica un requisito funzionale.
  \end{itemize}
  \item \textbf{Codice:} indica il codice identificativo del requisito, è 
  univoco e deve essere indicato in forma gerarchica.
\end{itemize}
Per ogni requisito si dovrà inoltre indicare: 
\begin{itemize}
  \item \textbf{Descrizione:} una breve descrizione, deve essere meno ambigua possibile;
  \item \textbf{Fonte:} la fonte può essere una delle seguenti:
  \begin{itemize}
    \item \textsl{Capitolato:} deriva direttamente dal testo del capitolato;
    \item \textsl{Verbale:} deriva da un incontro verbalizzato;
    \item \textsl{Interno:} deriva da discussioni interne al team;
    \item \textsl{Casi d'uso:} deriva da uno o più casi d'uso.
  \end{itemize}
\end{itemize} 
\paragraph{Classificazione dei casi d'uso}
Lo scopo del documento e quello di descrivere le motivazioni che hanno portato il gruppo alla scelta del capitolato C5.
Verranno inoltre riportate le descrizioni di tutti gli altri capitolati e le motivazioni che hanno spinto il gruppo a scartarli.

\subsubsection{Tracciamento}
Gli \textsl{Analisti} hanno il compito di inserire tutti i requisiti e i casi d'uso in \textsl{DocumentsDB},
software concesso dal gruppo \textsl{PragmaDB}, appositamente modificato da alcuni membri del 
team, che permette la gestione automatica della tracciabilità degli elementi inseriti. 
Inoltre i requisiti verranno inseriti in formato tabellare nel documento di \textsl{\AdR}.
\subsection{Progettazione}


\subsubsection{Descrizione}
L'attività di progettazione definisce come deve essere realizzata la struttura dell'architettura software. I requisiti delineati, all'interno del documento "Analisi dei Requisiti", devono essere utili a realizzare la documentazione specifica e a determinare le linee guida da seguire durante l'attività di codifica. 
Tale attività deve essere svolta in maniera ottimale e precisa dai progettisti.  
  
\subsubsection{Diagrammi}
La progettazione deve utilizzare le seguenti tipologie di diagrammi UML(G):
\begin{itemize} 
\item
Diagrammi di classi:illustra una collezione di elementi dichiarativi di un modello come classi e tipi, assieme ai loro contenuti e alle loro relazioni.  
\item
Diagrammi dei package:raggruppamenti di classi in una unità di livello più alto
\item
Diagrammi di attività:illustra il flusso di operazioni relativo ad un'attività. Utilizzati soprattutto per descrivere la logica di un algoritmo.  
\item
Diagrammi di sequenza: descrive una determinata sequenza di azioni dove tutte le scelte sono già state effettuate; in pratica nel diagramma non compaiono scelte, né flussi alternativi.
\end{itemize}


\subsubsection{Obbiettivi} (al Posto di Stili di Progettazione)

I progettisti sono responsabili delle attività di progettazione. Tali sono tenuti a:
\begin{itemize} 
\item
Produrre una soluzione attuabile, comprensibile, robusta e semplice entro i limiti del possibile;
\item
Effettuare scelte su aspetti progettuali applicando design pattern;
\item
Effettuare scelte su aspetti progettuali e tecnologici che rendano il prodotto facilmente mantenibile;
\item
Effettuare scelte su aspetti progettuali e tecnologici che rendano il prodotto modulare entro i limiti del possibile.
\item
Redigere la Specifica Tecnica, la Definizione di Prodotto e le sezioni inerenti le metriche di verifica della programmazione del Piano di Qualifica.
\end{itemize}
\subsubsection{Tracciamento}
Ogni requisito deve essere tracciato all'interno del documentsDB, software
appositamente creato da alcuni componenti del gruppo che permette la tracciabilità e la classificazione automatica degli elementi inseriti.

\subsection{Codifica}

\subsubsection{Descrizione}
L'attività di codifica ha come obiettivo passare dalla descrizione della soluzione in termini di architettura alla descrizione della soluzione in formato eseguibile da un calcolatore. I programmatori,responsabili di questa attitvità, sono tenuti a seguire le linee guida, delineate nell'attività di progettazione, con lo scopo di produrre in output il software designato. 

\subsubsection{Intestazione}

\subsubsection{Formattazione}

\subsubsection{Ricorsione}
La ricorsione va evitata quando possibile. Per ogni funzione ricorsiva sarà necessario fornire una prova di terminazione e sarà necessario valutare il costo in termini di occupazione della memoria. Nel caso l'utilizzo di memoria risulti troppo elevato la ricorsione verrà rimossa.

\subsection{Strumenti}

\subsubsection{DocumentsDB}(Da modificare)
Al fine di gestire in maniera veloce e il più possibile automatizzata tutti i dati, e
per semplificare i tracciamenti, il team ha creato un applicativo web: DocumentsDB.
DocumentsDB permette la gestione di casi d’uso, attori, fonti, requisiti e termini del Glossario. Ogni membro del teamG può accedervi via browser previa autenticazione, inoltre, più persone possono lavorare simultaneamente sugli stessi dati poiché è stata gestita la concorrenza. L’applicazione si occupa di mantenere ordinata la gerarchia dei requisiti e degli UC in modo automatico durante tutto il suo ciclo di vita (creazione, modifica, eliminazione).
Vengono eseguiti diversi controlli su ciascun campo dati, e tale approccio garantisce fault-toleranceG del sistema nei confronti di qualsiasi input possibile. I membri del gruppo possono visualizzare, inserire, modificare ed eliminare elementi in modo semplice. PragmaDB consente di esportare l’elenco degli attori, delle fonti, del Glossario, dei casi d’uso, dei requisiti e delle loro relazioni come codice LATEX, quindi facilmente inseribile all’interno dei documenti durante la stesura. Infine consente di visualizzare,
attraverso un menù laterale, l’insieme dei link utili relativi al gruppo.

\subsubsection{Tracciabilità}
La Tracciabilità dei requisiti e dei casi d'uso avviene tramite l'utilizzo del software DocumentsDB, il quale da la possibilità ad ogni membro del team di inserire, modificare o eliminare requisiti o casi d’uso. Inoltre è utilizzato per tenere traccia dello stato dei requisiti, ovvero se sono stati soddisfatti o meno.

\subsubsection{Sistema operativo}

\subsubsection{Strumenti di project management}
Gli strumenti di project management sono ritenuti centrali per lo sviluppo di un progetto in quanto consentono di monitorare i compiti tra i membri del team e controllare lo stato di avanzamento del progetto.
Il software di project management utilizzato dal team è Zoho Projects perchè, rispetto agli altri competitor, offre un ricco set di funzionalità riguardanti: la pianificazione, il monitoraggio, il reporting e la collaborazione.
Inoltre è disponibile l'applicazione mobile, utile ai membri del team per tenere sotto controllo le varie fasi di realizzazione da qualsiasi luogo.
  


\subsubsection{Strumenti per il versionamento}
Gli strumenti software per il controllo versione sono ritenuti molto spesso necessari per la maggior parte dei progetti di sviluppo software.
Per questo motivo, il team ha deciso di creare un repository, ospitato all'interno di un server, per gestire la continua evoluzione dei documenti digitali come il codice sorgente del software, la documentazione testuale e altre informazioni importanti.
Il software di versionamento scelto è Git perchè presenta molti più aspetti positivi rispetto ai repository centralizzati. Git permette di lavorare anche in assenza di connettività con il server centrale. I membri del team possono lavorare sulla propria copia locale del repository e rendere pubbliche le modifiche caricandole nel repository centrale. Questo approccio risulta molto semplice e veloce per poter collaborare con i membri del team simultaneamente.
Inoltre online è possibile reperire moltissima documentazione a riguardo per un rapido apprendimento. La struttura base del repository:
\begin{itemize}
  \item
	RR
	\begin{itemize}
		\item
			Interni
		\item
			Esterni
	\end{itemize}
  \item
    RQ
  \item
    RP
  \item
  	RA
  \item
  	Template 
\end{itemize}  
\subsubsection{Documentazione sorgenti}

\subsubsection{Framework}

\subsection{Tecnologie utilizzate}
\subsubsection{Html5}
Html5 è un linguaggio di markup per la strutturazione delle pagine web, derivato dallo standard che definisce HTML.
Il termine rappresenta due concetti differenti:
\begin{itemize}
		\item
			Una nuova versione del linguaggio HTML, con nuovi elementi, attributi e comportamenti
		\item
			Un più ampio insieme di tecnologie che permettono siti web e applicazioni più diversificate e potenti
\end{itemize}
HTML5 si presenta come un linguaggio pronto ad essere plasmato secondo le più recenti necessità, sia dal lato della strutturazione del contenuto che da quello dello sviluppo di vere e proprie applicazioni.
Questo linguaggio verrà utilizzato per sviluppare la parte client dell'applicativo.

\subsubsection{Css}
CSS è un linguaggio utilizzato per definire la formattazione di documenti HTML, XHTML e XML.
Questo linguaggio istruisce un browser su come il documento debba essere presentato all'utente, per esempio definendone la formattazione del testo, il posizionamento degli elementi rispetto a diversi media e device, etc.
Questa tecnologia verrà utilizzata per arricchire l'aspetto visuale e la presentazione della parte client.
\subsubsection{Javascript}
Javascript è un linguaggio di scripting lato-client per la creazione di effetti dinamici interattivi all'interno di una pagina Web. Esso è un linguaggio interpretato, cioè non esiste nessun compilatore, ma è direttamente il browser, tramite un apposito motore di scripting, che interpreta il linguaggio.
L’enorme diffusione di JavaScript è dovuta principalmente al fiorire di numerose librerie nate allo scopo di semplificare la programmazione sul browser, ma anche alla nascita di framework lato server e nel mondo mobile che lo supportano come linguaggio principale.
La parte dinamica dell'applicativo verrà sviluppata tramite l'utilizzo di questo linguaggio.

\subsubsection{Node.js}
Node.js è un framework relativo all'utilizzo server-side di Javascript.
La piattaforma è basata sul JavaScript Engine V8, che è il runtime di Google utilizzato anche da Chrome e disponibile sulle principali piattaforme, anche se maggiormente performante su sistemi operativi UNIX-like.
La caratteristica principale di Node.js risiede nella possibilità di accedere alle risorse del sistema operativo in modalità event-driven e non sfruttando il classico modello basato su processi o thread concorrenti, utilizzato dai classici web server.
Il modello event-driven, o "programmazione ad eventi", si basa su un concetto piuttosto semplice: si lancia una azione quando accade qualcosa. Ogni azione quindi risulta asincrona a differenza dei pattern di programmazione più comune in cui una azione succede ad un'altra solo dopo che essa è stata completata.
Tale modello di networking è ritenuto più efficiente nelle situazioni critiche in cui si verifica un elevato traffico di rete.
Node.js verrà utilizzato per sviluppare la parte server dell'applicativo.



