\newpage
\section{Strategie di verifica}
\subsection{Procedure di controllo qualità di processo}
Al fine di ottenere processi di qualità, si è deciso di utilizzare il modello \textit{CMM\ped{G}}, che affiancato al principio \textit{PDCA\ped{G}} garantisce un miglioramento continuo dei processi.\\
Il miglioramento sarà garantito da una continua procedura di valutazione della qualità e dei miglioramenti conseguiti durante lo svolgimento delle attività. Verranno utilizzate delle \textit{metriche\ped{G}} che permettono di quantificare in modo preciso la qualità dei processi.\\
Le metriche impiegate sono riportate nel dettaglio nella sezione 3.9 di questo documento. Oltre a queste, per poter monitorare la qualità dei processi è necessario che:
\begin{itemize}
\item L'operato del \textit{team\ped{G}} venga tenuto costantemente sotto controllo tramite verifiche;
\item L'assegnazione delle risorse venga effettuata in modo coerente e chiaro;
\item La pianificazione dei processi deve essere dettagliata.
\end{itemize}
Procedendo in questo modo sarà più semplice seguire l'operato del team e poterne dare una valutazione.

\subsection{Procedure di controllo qualità di prodotto}
Per quanto riguarda la qualità del prodotto, essa verrà garantita da:
\begin{itemize}
\item \textbf{Quality Assurance}: insieme di attività per garantire il raggiungimento degli obiettivi di qualità. Il controllo deve essere proattivo e non correttivo. Prevede l'attuazione di tecniche di analisi statica e dinamica, descritte nella sezione \textbf{???};
\item \textbf{Verifica}: si occupa di accertare che l'esecuzione delle attività di processi svolti nella fase in esame non abbia introdotto errori nel prodotto;
\item \textbf{Validazione}: certifica che i prodotti finali realizzati siano conformi alle attese. 
\end{itemize}

\subsection{Organizzazione}
Per ottenere il livello di qualità prefissato saranno necessarie attività di verifica e di validazione che seguiranno tutto lo sviluppo del prodotto. Queste attività saranno legate al tipo di revisione (interna o esterna) che il prodotto deve affrontare lungo il periodo di sviluppo. Il team\ped{G} ha deciso di utilizzare il modello incrementale come modello del ciclo di vita. L’organizzazione della strategia di verifica sarà divisa in base alle revisioni e definita come segue:
\begin{itemize}
\item \textbf{Revisione dei Requisiti}: le attività di verifica dovranno essere eseguite su ogni documento destinato alla \textbf{Revisione dei Requisiti} e ogniqualvolta il documento abbia subito un cambio di versione. Le attività che verranno svolte sui documenti sono:
\begin{itemize}
\item[-] Verifica della correttezza ortografica;
\item[-] Verifica della correttezza lessicale;
\item[-] Verifica della correttezza dei contenuti e la loro conformità alla natura del documento;
\item[-] Verificare che ogni requisito abbia corrispondenza con una fonte (\textit{caso d’uso, capitolato, ecc.});
\item[-] Verificare che ogni documento rispetti le \textit{\NdP}.
\end{itemize}
Inoltre sarà garantito il completo tracciamento dei requisiti e dei corrispondenti casi d’uso.
\item \textbf{Revisione di Progettazione}: arrivati a questa fase, sarà verificata e garantita la corrispondenza tra i requisiti definiti nelle fasi di \textbf{Analisi} e \textbf{Analisi di Dettaglio}, la cui consistenza e validità sono date dallo svolgimento delle attività del punto precedente, e i moduli software derivanti dalla progettazione.
\item \textbf{Revisione di Qualifica}: verranno svolte le attività di codifica e di esecuzione dei test di unicità per la verifica del codice nella maniera più automatizzata possibile, rispettando i vincoli statici. In parallelo i verificatori dovranno controllare la presenza di eventuali anomalie. Arrivati a questa fase verrà garantito che:
\begin{itemize}
\item[-] Ogni modulo software sia privo di errori e si comporti in maniera corretta con gli altri moduli;
\item[-] Ogni modulo sia direttamente riconducibile ad un requisito;
\item[-] Ogni requisito obbligatorio sia stato soddisfatto.
\end{itemize}
\item \textbf{Revisione di Accettazione}: tutte le attività svolte prima di questa fase garantiranno che il prodotto che è stato realizzato dal team \gruppo \hspace{1mm} funzioni in maniera corretta e conforme alle richieste e che tutti i requisiti siano stati adempiti.
\end{itemize}


\subsection{Pianificazione strategica e temporale}
L’obiettivo di rispettare le scadenze fissate nel \PdP v1.2.0 crea la necessità di avere un processo di verifica sistematico, organizzato e semplice. Per rispettare tali termini è richiesto che ogni membro del team studi a fondo le attività da eseguire, in modo da evitare errori comuni, interpretazioni sbagliate dei contenuti e improvvisazioni riguardo il compito da svolgere. Sarà necessario uno studio, a posteriori, atto a migliorare la qualità dei processi e ad aumentare la velocità di verifica e di svolgimento dei compiti. Questa attività andrà a classificare e quantificare gli errori più comuni e a verificare se sia necessaria l’introduzione di metodi aggiuntivi di verifica. Inoltre, permetterà di vedere quali attività richiedono più risorse così da poter migliorare la parallelizzazione delle attività ed aumentare l’efficienza. Di seguito vengono presentate le scadenze fissate:
\begin{itemize}
\item \textbf{Revisioni interne}
\begin{itemize}
\item[-] \textbf{Revisione di Progettazione}: 18 Aprile 2016
\item[-] \textbf{Revisione di Qualifica}: 23 Maggio 2016
\end{itemize}
\item \textbf{Revisioni esterne}
\begin{itemize}
\item[-] \textbf{Revisione dei Requisiti}: 16 Febbraio 2016
\item[-] \textbf{Revisione di Accettazione}: 17 Giugno 2016
\end{itemize}
\end{itemize}


\subsection{Responsabilità}
Il \textit{Responsabile di Progetto} ha la responsabilità relativa all’assegnazione degli incarichi e quella derivata dai rapporti con gli stakeholders. A carico dell’\textit{Amministratore} è invece la responsabilità di fornire un ambiente di lavoro adeguato per lo svolgimento in modo corretto di tutti i compiti necessari alla realizzazione del progetto. Concluso il processo di verifica, il \textit{Verificatore} si prende la responsabilità sul documento o modulo software preso in esame. Inoltre ogni membro del team è responsabile per tutto il materiale da esso prodotto.


\subsection{Risorse}
Verranno di seguito elencate le risorse che serviranno per il corretto sviluppo del prodotto software.Tali risorse si possono racchiudere in due categorie.

\subsubsection{Necessarie}
Alcune risorse sono considerate necessarie per lo svolgimento del prodotto, queste sono:
\begin{itemize}
\item \textbf{Risorse umane}: sono le figure professionali necessarie nel team.
\begin{itemize}
\item[-] \textit{Responsabile di Progetto};
\item[-] \textit{Amministratore};
\item[-] \textit{Analista};
\item[-] \textit{Progettista};
\item[-] \textit{Programmatore};
\item[-] \textit{Verificatore}.
\end{itemize}
\item \textbf{Risorse software}: sono le applicazioni necessarie per:
\begin{itemize}
\item[-] La stesura dei documenti in formato LATEX; 
\item[-] La creazione di diagrammi UML;
\item[-] Lo sviluppo di codice nei vari linguaggi scelti;
\item[-] Effettuare l'analisi statica del codice;
\item[-] Effettuare i vari test sul codice;
\item[-] Automatizzare il più possibile i processi di verifica.
\end{itemize}
Tutti i software che verranno utilizzati sono descritti nelle \textit{\NdP}.
\item \textbf{Risorse Hardware}: Sono necessari computer per poter eseguire le applicazioni citate in precedenza, server che conterranno gli applicativi per gestione del ticketing, continuos integration, mail, repository e database.
\end{itemize}

\subsubsection{Disponibili}
\begin{itemize}
\item \textbf{Risorse umane}: tutte le figure professionali descritte in precedenza verranno rappresentate dai membri del team.
\item \textbf{Risorse software}: sono disponibili per il team tutti i software descritti nelle \textit{\NdP}, gran parte di loro sono free e per altri è stato possibile ottenere una licenza per studenti.
\item \textbf{Risorse Hardware}: ogni membro del team\ped{G} dispone di un computer proprio, in alternativa sono disponibili quelli presenti nei laboratori dell’Università degli Studi di Padova. Per quanto riguarda i server, ..... 
\end{itemize}


\subsection{Strumenti}
Gli strumenti software sono descritti in dettaglio nel documento \textit{Norme di Progetto}. Essi vengono impiegati per:
\begin{itemize}
\item \textbf{Versionamento};
\item \textbf{Redazione dei documenti};
\item \textbf{Verifica dei documenti};
\item \textbf{Codifica del software};
\item \textbf{Verifica del codice};
\item \textbf{Organizzazione del gruppo};
\item \textbf{Condivisione dei file};
\end{itemize}


\subsection{Tecniche di analisi}

\subsubsection{Analisi statica}
L’analisi statica è una tecnica di verifica applicabile ai documenti e al codice. Verrà impiegata durante tutto lo sviluppo del sistema e sarà automatizzata il più possibile mediante gli strumenti descritti nelle \textit{Norme di Progetto}. L’analisi statica applicata al software non necessita che i programmi vengano eseguiti, bensì mira a trovare anomalie ed errori di sintassi e a fare predizioni sulla qualità e la manutenibilità del codice prodotto. In seguito vengono riportate le metodologie di applicazione dell’analisi statica.

\subsubsection{Walkthrough}
Questo metodo di applicazione dell’analisi statica consiste in una lettura del documento o del codice ricercando anomalie ed errori a largo spettro, ovvero senza una conoscenza precisa dei tipi di errori che è possibile riscontrare. Il walkthrough verrà applicato nelle prime fasi dello sviluppo poiché non si possiede ancora la concezione dei possibili e più frequenti errori. Mediante questa tecnica, verrà stilata una lista di controllo contenente gli errori rilevati più spesso. Quando la lista di controllo dei verificatori sarà sufficientemente completa, verrà allegata in appendice al documento \textit{Norme di Progetto} e dal walkthrough si passerà all’utilizzo della tecnica di inspection.

\subsubsection{Inspection}
Questa tecnica consiste in una lettura mirata dei documenti o del codice. Viene impiegata una lista di controllo contenente gli errori più probabili o commessi con maggior frequenza, al fine di rilevarli durante l’inspection. Poiché questa lista verrà ampliata con l’acquisizione di esperienza nella verifica, l’inspection diverrà sempre più efficace.

\subsubsection{Analisi dinamica}
Questa tipologia di analisi è applicata solamente al software prodotto e alle sue componenti. L’analisi dinamica viene svolta mediante test che verificano il funzionamento di componenti software e che ne identificano eventuali errori. Per ogni test è necessario definire:
\begin{itemize}
\item \textbf{Ambiente}: è il sistema hardware e software sul quale è pianificata l’esecuzione del test. Inoltre, è necessario specificare uno stato iniziale di partenza per il test;
\item \textbf{Specifica}: rappresenta l’insieme degli input e dei corrispondenti output attesi;
\item \textbf{Procedure}: si tratta di una specifica di istruzioni su come eseguire il test e di come i risultati devono essere interpretati e analizzati.
\end{itemize}
Affinché si possano ottenere risultati attendibili, è necessario che i test siano ripetibili, ovvero dato un certo input la loro esecuzione nello stesso ambiente deve produrre in output sempre gli stessi risultati. In seguito sono elencati i tipi di test effettuati sui prodotti software.

\paragraph{Test di unità}
Per unità di prodotto software si intende la più piccola quantità software che risulta conveniente verificare singolarmente, tipicamente quella prodotta da un singolo programmatore. Ad esempio solitamente un modulo è parte dell’unità ed il componente invece integra più unità. I test di unità verificano che ogni unità funzioni correttamente, evidenziando errori di implementazione. Questi test verranno effettuati sui moduli base che compongono il software.

\paragraph{Test di integrazione}
Questo tipo di test verifica che due o più unità, tipicamente moduli, precedentemente verificati, una volta assemblati funzionino correttamente. I test di integrazione possono aiutare a rilevare errori residui sui moduli e verificano anche che l’eventuale cooperazione di essi con componenti esterni, quali framework e librerie, non produca anomalie.

\paragraph{Test di regressione}
Questo test consiste nel rieseguire tutti i test su un componente che ha subito una modifica. In questo modo si vuole verificare che il resto dei moduli continui a funzionare correttamente. Inoltre eseguire dei test di regressione consente di capire quali test sono a rischio di inesattezza in caso di modifiche al codice dei prodotti.

\paragraph{Test di sistema}
Un test di sistema viene eseguito su un prodotto che si ritiene essere giunto ad una versione definitiva. Viene perciò verificato che il prodotto soddisfi tutti i requisiti imposti. Questo test è quindi la validazione dei prodotti software.

\paragraph{Test di accettazione}
Il test di accettazione coincide con il collaudo del software in presenza del Proponente. In caso di esito positivo, questo test determina un grado di maturità del prodotto tale da consentirne il rilascio.


\subsection{Misure e metriche}
Poichè il processo di verifica deve essere quantificabile, è necessario stabilire delle metriche, applicabili a prodotti e processi, con cui confrontare le misure rilevate da tale processo. Si ha esito positivo dal processo di verifica quando una misura rilevata rientra in uno di questi intervalli:
\begin{itemize}
\item \textbf{Intervallo di accettazione}: intervallo di valori entro il quale un prodotto viene accettato;
\item \textbf{Intervallo di ottimalità}: intervallo di valori entro il quale il risultato viene considerato ottimo. Ogni misura rilevata dal processo di verifica dovrebbe collocarsi al suo interno. Per questo se essa si scosta dai valori dell'intervallo ottimale, necessita di una verifica più approfondita.
\end{itemize} 
Il modello di ciclo di vita adottato (descritto nel \PdP) consente di migliorare in modo incrementale le metriche utilizzate, qualora alcune di esse risultassero approssimate.


\subsubsection{Metriche per i processi}


\paragraph{Valutazione CMM}
La valutazione dei processi avverrà attraverso il modello CMM\ped{G} (Capability Maturity Model). Tale modello opera secondo due parametri di valutazione:
\begin{itemize}
\item \textbf{Capability}: è una caratteristica valutata sui processi presi singolarmente. Determina quanto è adeguato un processo, in termini di efficienza ed efficacia, per gli scopi per cui è stato definito;
\item \textbf{Maturity}: è una caratteristica posseduta da un insieme di processi, risultante dalla combinazione delle capability dei processi coinvolti. Essa indica quanto è governato il sistema di processi di un'azienda.
\end{itemize}
Per entrambe verrà assegnato un voto da 1 (stato iniziale) a 5 (stato controllato), indicante la valutazione complessiva.\\
Sono state valutate anche altre alternative, quali il modello CMMI e lo standard [ISO\ped{G}/IEC 15504]. Il gruppo ha però scelto il modello CMM\ped{G} per diversi fattori, quali l’essenzialità della valutazione (CMM\ped{G} valuta secondo due soli parametri, CMMI e [ISO\ped{G}/IEC 15504] dividono invece il processo in più attributi) e l’inesperienza del team\ped{G}, infatti utilizzare modelli più complessi comporta un bagaglio di esperienza che il gruppo non ha ancora acquisito.\\
Gli intervalli di accettazione stabiliti dal gruppo per la valutazione CMM\ped{G} sono:
\begin{itemize}
\item \textbf{Intervallo di accettazione}: 3 - 5;
\item \textbf{Intervallo di ottimalità}: 4 - 5.
\end{itemize}
\subsubsection{Metriche per i documenti}
\paragraph{Indice Gulpease}
Questa metrica fornisce un indice di leggibilità e complessità di un documento. Il calcolo da effettuare è:\\
\begin{center}
${89 + \frac{300(\textit{numero delle frasi}) - 10(\textit{numero delle lettere})}{\textit{numero delle parole}}}$
\end{center}
Per semplificarne l’utilizzo, sono stati scritti degli script appositi. I risultati del calcolo sono compresi tra 0 e 100, con 100 a rappresentare la massima leggibilità. Sono state stabilite inoltre delle soglie che rapportano il livello di istruzione del lettore con i gradi dell’indice Gulpease\ped{G}:
\begin{itemize}
\item \textbf{inferiore a 80}: testo difficile da leggere per chi ha la licenza elementare;
\item \textbf{inferiore a 60}: testo difficile da leggere per chi ha la licenza media;
\item \textbf{inferiore a 40}: testo difficile da leggere per chi ha la licenza superiore.
\end{itemize}
Va considerato che questo indice non indica se il testo sia comprensibile: pur stravolgendo il significato delle frasi si potrebbe ottenere comunque un valore alto. Per questo motivo il testo dei documenti deve essere controllato anche da un essere umano. L’impiego dell’indice di Gulpease fornisce responsi sulla leggibilità ma per la natura tecnica di questi documenti, difficilmente si raggiungerà il valore 80. Per i documenti del progetto sono stati definiti i seguenti intervalli di valori con cui confrontare i risultati del calcolo dell’indice:
\begin{itemize}
\item \textbf{Intervallo di accettazione}: 40 - 100;
\item \textbf{Intervallo di ottimalità}: 50 - 100.
\end{itemize}

\paragraph{Controllo ortografico}
Il controllo ortografico sui documenti è automatizzato tramite script e consente di evidenziare errori nella sintassi delle parole. Per superare il processo di verifica un documento deve necessariamente contenere 0 errori ortografici. Il controllo dell’ortografia non evidenza errori riguardanti il significato delle frasi e può segnalare errori su termini tecnici, soprattutto se espressi in inglese. Per questo motivo è richiesta inoltre una lettura approfondita del documento in esame da parte di un essere umano.

\paragraph{Controllo dei diagrammi UML}
Poiché non è possibile utilizzare un sistema automatico per individuare errori di sintassi nelle parti testuali che compongono i diagrammi dei casi d’uso e delle classi. Per questo motivo è necessaria un’attenta lettura da parte di un essere umano.

\subsubsection{Metriche per il codice}
\paragraph{Complessità ciclomatica}
La complessità ciclomatica\ped{G} è utilizzata per misurare la complessità di un programma. Essa misura il numero di cammini linearmente indipendenti attraverso il grafo di controllo di flusso di un metodo, di una funzione o di un programma. In questo grafo i nodi rappresentano unità atomiche di istruzioni, mentre gli archi che collegano i nodi rappresentano la sequenzialità con cui possono essere eseguite le istruzioni.\\
Un valore di complessità ciclomatica\ped{G} superiore a 10, per un metodo o una funzione, deve essere abbassato con la suddivisione in più metodi o funzioni.
\begin{itemize}
\item \textbf{Intervallo di accettazione}: 0 - 10;
\item \textbf{Intervallo di ottimalità}: 0 - 6.
\end{itemize}

\paragraph{Rapporto linee di commento su linee di codice}
Questa metrica aiuta a stimare la manutenibilità del codice: documentare il codice attraverso linee di commento ne permette infatti una comprensione più immediata e approfondita. In tale metrica vengono escluse le linee vuote.\\
Gli intervalli per le misure rilevate sono:
\begin{itemize}
\item \textbf{Intervallo di accettazione}: almeno 0.25;
\item \textbf{Intervallo di ottimalità}: almeno 0.30.
\end{itemize}

\paragraph{Numero di parametri}
Indica il numero di parametri formali presenti nella segnatura di un metodo o di una funzione. Un numero di parametri elevato può significare che lo stack\ped{G} del programma venga riempito rapidamente in caso di chiamate multiple o innestate e pregiudica l’usabilità e la comprensione del metodo o della funzione.\\
Gli intervalli per le misure rilevate sono:
\begin{itemize}
\item \textbf{Intervallo di accettazione}: 0 - 8;
\item \textbf{Intervallo di ottimalità}: 0 - 5.
\end{itemize}

\paragraph{Numero di campi dati per classe}
Un numero elevato di campi dati interni a una classe è indice di cattiva progettazione: la classe risulterà troppo poco specializzata ed il codice sarà poco mantenibile. Ridurre il numero di campi dati per classe è possibile attraverso l’incapsulamento in classi interne o la suddivisione in sottoclassi.\\
Gli intervalli per le misure rilevate sono:
\begin{itemize}
\item \textbf{Intervallo di accettazione}: 0 - 8;
\item \textbf{Intervallo di ottimalità}: 0 - 5.
\end{itemize}

\paragraph{Chiamate annidate di metodi e funzioni}
Avere un numero elevato di chiamate di funzioni e metodi all’interno di altri metodi e funzioni può portare a riempire rapidamente lo stack\ped{G} del programma.\\
Gli intervalli per le misure rilevate sono:
\begin{itemize}
\item \textbf{Intervallo di accettazione}: 0 - 8;
\item \textbf{Intervallo di ottimalità}: 0 - 5.
\end{itemize}

\paragraph{Dipendenze}
Nell’ambito di Javascript\ped{G} è comune l’utilizzo di molte librerie\ped{G} spesso dipendenti tra loro. Risulta quindi necessario quantificare le dipendenze tra gli script e le librerie\ped{G} presenti nel progetto: un numero troppo elevato è sintomo di scarsa progettazione, così come un numero troppo basso può significare librerie\ped{G} troppo grandi e scarsamente mantenibili.\\
Gli intervalli per le misure rilevate sono:
\begin{itemize}
\item \textbf{Intervallo di accettazione}: 0 - 16;
\item \textbf{Intervallo di ottimalità}: 0 - 8.
\end{itemize}

\paragraph{Indice di Manutenibilità}
L’Indice di Manutenibilità (Maintainability Index, abbreviato in MI) è una metrica che indica quanto il codice prodotto risulta mantenibile. In particolare quando occorre effettuare una modifica indica se è più conveniente riscrivere l’intero codice o effettuare il cambiamento. L’Indice di Manutenibilità è calcolato dal software dedicato all’analisi della complessità sulla base di altre metriche, come la complessità ciclomatica\ped{G} e le linee di codice. I valori sono su una scala logaritmica con intervallo tra infinito negativo e 171. Più il valore è alto, più lo sarà anche il livello di manutenibilità.\\
\begin{itemize}
\item \textbf{Intervallo di accettazione}: 65 - 171;
\item \textbf{Intervallo di ottimalità}: 85 - 171.
\end{itemize}

\paragraph{Validazione W3C}
Il test di validazione per l’applicazione web\ped{G} messo a disposizione da W3C\ped{G} deve essere superato sia dalle pagine HTML\ped{G} che dai file CSS\ped{G} con 0 errori gravi. Per quanto riguarda le pagine HTML\ped{G}, sono ammesse inesattezze fino ad un totale di 5 che non pregiudichino però la funzionalità dell’applicazione.
\begin{itemize}
\item \textbf{Intervallo di accettazione}: 0 - 5;
\item \textbf{Intervallo di ottimalità}: 0 - 0.
\end{itemize}