\newpage
\section{Strategie di verifica}
\subsection{Definizione degli obiettivi}
\subsubsection{Standard per la qualità di processo}
Per garantire la qualità del prodotto è necessario perseguire la qualità dei processi che lo definiscono. Per fare ciò si è deciso di adottare lo standard \textit{ISO/IEC 15504}\ped{G} denominato \textit{SPICE}\ped{G} il quale fornisce gli strumenti necessari a valutare la qualità di questi ultimi.\\
Per applicare correttamente questo modello si deve utilizzare il ciclo \textit{PDCA}\ped{G} che definisce una metodologia di controllo dei processi durante il loro ciclo di vita e che consente di migliorarne in modo continuativo la qualità. 

\subsubsection{Standard per la qualità di prodotto}
Al fine di aumentare il valore commerciale di un prodotto software e di garantirne il corretto funzionamento è necessario fissare degli obiettivi qualitativi e di assicurare che questi vengano effettivamente rispettati.\\
Lo standard \textit{ISO/IEC 9126}\ped{G} è stato redatto con lo scopo di descrivere questi obiettivi e delineare delle metriche capaci di misurare il raggiungimento di tali obiettivi.

\subsection{Procedure per il controllo della qualità di processo}
La qualità dei processi sarà garantita dall'applicazione del principio \textit{PDCA}\ped, descritto nell'appendice A. Così facendo, sarà possibile garantire un miglioramento continuo della qualità di tutti i processi, inclusa la verifica, ottenendo di conseguenza il miglioramento dei prodotti risultanti.\\
Per avere controllo sulla qualità è necessario che:
\begin{itemize}
\item I processi siano pianificati nel dettaglio;
\item Nella pianificazione siano ripartite in modo chiaro le risorse;
\item I processi vengano costantemente monitorati.
\end{itemize}
L'attuazione di tali punti è descritta dettagliatamente nel \textit{\PdP}.\\
La qualità dei processi viene inoltre monitorata mediante l'analisi costante della qualità del prodotto e quantificata utilizzando varie metriche, descritte nella sezione 2.9.1. Un prodotto di bassa qualità indica un processo da migliorare.

\subsection{Procedure per il controllo della qualità di prodotto}
Il controllo di qualità del prodotto verrà garantito da:
\begin{itemize}
\item \textbf{Quality Assurance}\ped{G}: insieme di attività realizzate per garantire il raggiungimento degli obiettivi di qualità. Prevede l'attuazione di tecniche di analisi statica e dinamica, descritte nella sezione 2.8;
\item \textbf{Verifica}: processo che determina se l'output di una fase è consistente, completo e corretto. La verifica andrà eseguita costantemente durante l'intera durata del progetto;
\item \textbf{Validazione}: conferma in modo oggettivo che il sistema risponda ai requisiti. 
\end{itemize}

\subsection{Organizzazione}
L'organizzazione della strategia di verifica si basa sull'attuazione di attività di verifica per ogni processo attuato. Per ogni processo realizzato viene verificata la qualità del processo stesso e la qualità dell'eventuale prodotto ottenuto da esso.\\
Ognuna delle fasi di progetto descritte nel \textit{\PdP} necessita di diverse attività di verifica a causa della differente natura degli output ottenuti.\\
Essendo la redazione dei documenti un'attività predominante e costantemente presente nel progredire del progetto, il processo di verifica si suddividerà in due attività per garantirne una maggiore qualità: Analisi e Analisi di Dettaglio. In ogni documento viene inoltre incluso il diario delle modifiche che permette di mantenere uno storico delle attività svolte e delle relative responsabilità.

\subsection{Pianificazione strategica e temporale}
Avendo l'obiettivo di rispettare le scadenze fissate nel \textit{\PdP}, è necessario che l'attività di verifica della documentazione sia sistematica e ben organizzata. Procedendo in questo modo, l'individuazione e la correzione di eventuali errori avverrà il prima possibile, impedendo una loro rapida diffusione. Ogni attività di redazione dei documenti e di codifica deve essere preceduta da uno studio preliminare sulla struttura e sui contenuti degli stessi con lo scopo di ridurre la possibilità di commettere imprecisioni di natura concettuale e tecnica favorendo quindi l'attività di verifica, dove saranno necessari minori interventi di correzione.

\subsection{Responsabilità}
Per garantire che il processo di verifica sia efficace e sistematico vengono attribuite delle responsabilità a degli specifici ruoli di progetto.\\
I ruoli che detengono le responsabilità del processo di verifica sono il \textit{Responsabile di Progetto} ed i \textit{Verificatori}. La suddivisione dei compiti e le modalità di attuazione degli stessi sono definiti nelle \textit{\NdP}.

\subsection{Risorse}
Per assicurare che gli obiettivi qualitativi vengano raggiunti è necessario l'utilizzo di risorse sia umane che tecnologiche. Coloro che detengono la responsabilità maggiore per l'attività di verifica e validazione sono il \textit{Responsabile di Progetto} e il \textit{Verificatore}.\\
Per risorse tecniche e tecnologiche sono da intendersi tutti gli strumenti software e hardware che il gruppo intende utilizzare per attuare le attività di verifica su processi e prodotti. Per agevolare il lavoro dei \textit{Verificatori} sono stati impiegati numerosi strumenti automatici che eseguono controlli sistematici sui prodotti generati. Tali strumenti sono descritti nelle \textit{\NdP}.

\subsection{Tecniche di analisi}
\subsubsection{Analisi statica}
L'analisi statica è una tecnica di analisi che permette di effettuare la verifica di quanto prodotto individuando errori ed anomalie, applicabile sia alla documentazione che al codice. Essa può essere svolta in due modi distinti ma complementari.

\paragraph{Walkthrough}
Si svolge effettuando una lettura critica a largo spettro. E' una tecnica che viene utilizzata soprattutto nelle prime attività del progetto, quando ancora non è presente una adeguata esperienza da parte dei membri del gruppo, che permetta di attuare una verifica più mirata e precisa.\\
Con l'utilizzo di questa tecnica, il \textit{Verificatore} sarà in grado di stilare una lista di controllo con gli errori più frequenti in modo da favorire il miglioramento di tale attività nelle fasi future.\\
Questa è un'attività onerosa e collaborativa che richiede l'intervento di più persone per essere efficacie ed efficiente. Dopo una prima fase di lettura ed individuazione degli errori, segue una fase di discussione con la finalità di esaminare i difetti riscontrati e di proporre le dovute correzioni. L'ultima fase consiste nel correggere gli errori rilevati nello scrivere un rapporto che elenchi le modifiche effettuate.

\paragraph{Inspection}
Questa tecnica consiste nell'analisi mirata di alcune parti del documento o del codice che sono ritenute fonti maggiori di errore. La \textit{lista di controllo}, che deve essere seguita per svolgere efficacemente questo processo, deve essere redatta anticipatamente ed è frutto dell'esperienza maturata dai verificatori attraverso la tecnica di \textit{Walkthrough}\ped{G}.\\
L'\textit{Inspection}\ped{G} è una strategia più rapida del \textit{Walkthrough}\ped{G} in quanto consente l'analisi di alcune parti dei prodotti ritenute critiche dalla checklist e non necessita della lettura integrale dei documenti in oggetto.\\
Diversamente dal \textit{Walkthrough}\ped{G} tale tecnica viene svolta esclusivamente dai verificatori che dopo aver individuato gli errori procedono alla loro correzione e alla redazione di un rapporto di verifica che tenga traccia del lavoro svolto.

\subsubsection{Analisi dinamica}
L'analisi dinamica si applica solamente al prodotto software e viene svolta durante l'esecuzione del codice mediante l'uso di test predisposti per verificarne il funzionamento e rilevare possibili difetti di implementazione.\\
Affinché tale attività sia utile e generi risultati attendibili è necessario che i test effettuati siano ripetibili: questa caratteristica è fondamentale in quanto solo un test che, dato un certo input, produce sempre lo stesso output su uno specifico ambiente, è capace di riscontrare problemi e verificare la correttezza del prodotto software.\\
Di conseguenza devono essere definiti a priori:
\begin{itemize}
\item \textbf{Ambiente}: consiste sia del sistema hardware che di quello software sui quali è stato pianificato l'utilizzo del prodotto software sviluppato; di essi deve essere specificato uno stato iniziale dal quale poter iniziare ad eseguire i test;
\item \textbf{Specifica}: consiste nel definire quali input sono necessari per l'esecuzione del test e quali devono essere gli output attesi;
\item \textbf{Procedure}: consiste nel definire come devono essere svolti i test, in quale ordine e come devono essere analizzati i risultati ottenuti.
\end{itemize}
Sono definibili 5 diversi tipi di test: 
\begin{itemize}
\item Test di unità;
\item Test di integrazione;
\item Test di sistema;
\item Test di regressione;
\item Test di accettazione.  
\end{itemize}

\paragraph{Test di unità}
Consiste nella verifica di ogni singola unità del prodotto software tramite l'utilizzo di \textit{stub}\ped{G}, \textit{driver}\ped{G} e \textit{logger}\ped{G}.\\
Per unità si intende la più piccola quantità di software che è utile verificare singolarmente e che viene prodotta da un singolo programmatore.\\
Attraverso tali test si vuole verificare il corretto funzionamento dei moduli che compongono l'intero sistema in modo da eliminare possibili errori di implementazione da parte dei programmatori.

\paragraph{Test di integrazione}
Consiste nella verifica dei componenti del sistema che vengono aggiunti incrementalmente al prodotto e si prefigge quindi di analizzare che la combinazione di due o più unità software funzionino come previsto.\\
Questo tipo di test serve ad individuare errori residui nella realizzazione dei singoli moduli, modifiche delle interfacce e comportamenti inaspettati di componenti software preesistenti forniti da terze parti che non si conoscono a fondo.\\
Per effettuare tali test devono essere aggiunte delle componenti fittizie al posto di quelle che non sono ancora state sviluppate, in modo da non influenzare negativamente l'esito dell'analisi.

\paragraph{Test di sistema}
Consiste nella validazione del prodotto software nel momento in cui lo si ritiene giunto ad una versione definitiva.\\
Tale test deve verificare che la copertura dei requisiti software stabilite in fase di Analisi di Dettaglio sia totale.

\paragraph{Test di regressione}
Consiste nell'eseguire nuovamente i test riguardanti le componenti software che hanno subito modifiche, in modo da controllare che i cambiamenti apportati non pregiudichino il funzionamento di componenti che non sono stati aggiornati e che precedentemente non erano soggetti ad errori.\\
Tale operazione è aiutata dal tracciamento, che permette di individuare e ripetere facilmente i test di unità, integrazione ed eventualmente sistema che sono stati potenzialmente influenzati dalla modifica.

\paragraph{Test di accettazione}
E' il collaudo del prodotto software che viene eseguito in presenza del proponente. Se tale collaudo viene superato positivamente si può procedere al rilascio ufficiale del prodotto sviluppato.

\subsection{Misure e metriche}
Il processo di verifica, per essere informativo, deve essere quantificabile. Le misure rilevate dal processo di verifica devono quindi essere basate su metriche stabilite a priori. Le metriche incerte, qualora ce ne fossero, si miglioreranno in modo incrementale. Essendo la natura delle metriche molto variabile, vi possono essere due tipologie di range:
\begin{itemize}
\item \textbf{Accettazione}: valori richiesti affinché il prodotto sia accettato;
\item \textbf{Ottimale}: valori entro cui dovrebbe collocarsi la misurazione. Tale range non è vincolante, ma fortemente consigliato. Scostamenti da tali valori necessitano una verifica approfondita.
\end{itemize}

\subsubsection{Metriche per i processi}
Come metrica per i processi si è scelto di utilizzare indici che ne analizzino i costi e i tempi.\\
Tali indici vengono utilizzati anche per mantenere il controllo sui processi durante il loro svolgimento.

\paragraph{Schedule Variance (SV)}
Indica se si è in linea, in anticipo o in ritardo rispetto la pianificazione temporale delle attività nella \textit{baseline}\ped{G}.\\
E' un indicatore di efficacia.\\
Se $SV > 0$ significa che il gruppo di lavoro sta producendo con maggior velocità rispetto a quanto pianificato, viceversa se negativo.\\
\textbf{Parametri utilizzati}:
\begin{itemize}
\item Range-accettazione: $[\geq-(\textit{costo preventivo fase}\times5\%)]$;
\item Range-ottimale: $[\geq0]$.
\end{itemize}

\paragraph{Budget Variance (BV)}
Indica se alla data corrente si è speso di più o di meno rispetto a quanto pianificato.\\
E' un indicatore che ha un valore contabile e finanziario.\\
Se $BV > 0$ significa che l'attuazione del progetto sta consumando il proprio budget con minor velocità rispetto a quanto pianificato, viceversa se negativo.\\
\textbf{Parametri utilizzati}:
\begin{itemize}
\item Range-accettazione: $[\geq-(\textit{costo preventivo fase}\times10\%)]$;
\item Range-ottimale: $[\geq0]$.
\end{itemize}

\subsubsection{Metriche per i documenti}
Come metrica per i documenti redatti si è scelto di utilizzare l'indice di leggibilità.\\
Vi sono a disposizione molti indici di leggibilità, ma i più importanti sono per la lingua inglese. Si è deciso quindi di adottare un indice di leggibilità per la lingua italiana.

\paragraph{Gulpease}
L'indice \textit{Gulpease}\ped{G} è un indice di leggibilità di un testo tarato sulla lingua italiana.\\
Rispetto ad altri ha il vantaggio di utilizzare la lunghezza delle parole in lettere anziché in sillabe, semplificandone il calcolo automatico. Permette di misurare la complessità dello stile di un documento.\\
L'indice \textit{Gulpease}\ped{G} considera due variabili linguistiche: la lunghezza della parola e la lunghezza della frase rispetto al numero delle lettere.\\
L'indice è calcolato secondo la seguente formula:
\begin{center}
$89+\frac{300\times(\textit{numero delle frasi})-10\times(\textit{numero delle lettere})}{\textit{numero delle parole}}$
\end{center}
I risultati sono compresi tra 0 e 100, dove il valore 100 indica la leggibilità più alta e 0 la leggibilità più bassa. In generale risulta che documenti aventi un indice:
\begin{itemize}
\item Inferiore a 80 sono difficili da leggere per chi ha la licenza elementare;
\item Inferiore a 60 sono difficili da leggere per chi ha la licenza media;
\item Inferiore a 40 sono difficili da leggere per chi ha un diploma superiore.
\end{itemize}
\textbf{Parametri utilizzati}:
\begin{itemize}
\item Range-accettazione: $[40-100]$;
\item Range-ottimale: $[50-100]$.
\end{itemize}

\subsubsection{Metriche per il software}
Per poter perseguire gli obiettivi di qualità software, è auspicabile applicare le metriche che ora verranno descritte.\\
Questa sezione è da comprendersi come una dichiarazione di intenti, che verrà rivista nelle prossime revisioni.

\paragraph{Complessità ciclomatica}
Utilizzata per misurare la complessità di funzioni, moduli, metodi o classi di un programma.\\
La \textit{complessità ciclomatica}\ped{G} è calcolata utilizzando il grafo di controllo di flusso del programma: i nodi del grafo corrispondono a gruppi indivisibili di istruzioni, mentre gli archi connettono due nodi se il secondo gruppo di istruzioni può essere eseguito immediatamente dopo il primo gruppo.\\
Altri valori di  \textit{complessità ciclomatica}\ped{G} implicano una ridotta manutenibilità del codice. Valori bassi di  \textit{complessità ciclomatica}\ped{G} potrebbero però determinare scarsa efficienza dei metodi.\\
Questo parametro è inoltre un indice del carico di lavoro richiesto per il testing. Un modulo con complessità elevata richiede più testing di un modulo a complessità inferiore.\\
Parametri utilizzati:
\begin{itemize}
\item Range-accettazione: $[1-15]$;
\item Range-ottimale: $[1-10]$.
\end{itemize}

\paragraph{Numero di livelli di annidamento}
Rappresenta il numero di livelli di annidamento dei metodi, cioè l'inserimento di una struttura di controllo all'interno di un'altra.\\
Un valore elevato di tale indice implica un'alta complessità ed un basso livello di astrazione del codice.\\
Parametri utilizzati:
\begin{itemize}
\item Range-accettazione: $[1-6]$;
\item Range-ottimale: $[1-3]$.
\end{itemize}

\paragraph{Attributi per classe}
Un numero elevato di attributi interni ad una classe potrebbe evidenziare la necessità di suddividere la classe in più classi da mettere in relazione tra di loro, seguendo il principio dell'\textit{incapsulamento}\ped{G}.\\
Un alto valore di questo attributo indica un possibile errore di progettazione.\\
Parametri utilizzati:
\begin{itemize}
\item Range-accettazione: $[0-16]$;
\item Range-ottimale: $[3-8]$.
\end{itemize}

\paragraph{Numero di parametri per metodo}
Un numero elevato di parametri per un metodo potrebbe evidenziare la necessità di ridurre le funzionalità associate a tale metodo.\\
Un alto valore di questo attributo indica un possibile errore di progettazione.\\
Parametri utilizzati:
\begin{itemize}
\item Range-accettazione: $[0-8]$;
\item Range-ottimale: $[0-4]$.
\end{itemize}

\paragraph{Linee di codice per linee di commento}
Indica il rapporto tra linee di codice e linee di commento.\\
E' utile per stimare la manutenibilità del codice.\\
Parametri utilizzati:
\begin{itemize}
\item Range-accettazione: $[>0.25]$;
\item Range-ottimale: $[>0.30]$.
\end{itemize}

\paragraph{Flusso di informazioni}
Misura il flusso di informazioni come suggerito da S. Henry e D. Kafura.\\
Definiti:
\begin{itemize}
\item \textbf{Fan-in}: numero di moduli che passano informazioni dentro al modulo in esame;
\item \textbf{Fan-out}: numero di moduli a cui il modulo in esame passa informazioni.
\end{itemize}
Il valore è calcolato come:
\begin{center}
$(\textit{lunghezza funzione})^2\times\textit{fan-in}\times\textit{fan-out}$
\end{center}

\paragraph{Accoppiamento}
\begin{itemize}
\item \textbf{Accoppiamento afferente}: indica il numero di classi esterne ad un \textit{package}\ped{G} che dipendono da classi interne ad esso.\\
Un alto valore di tale indice implica un alto grado di dipendenza del resto del software dal \textit{package}\ped{G}.\\
Alti valori di tale indice non implicano necessariamente una progettazione errata o di bassa qualità, ma possono rappresentare la criticità del \textit{package}\ped{G} in esame. Tale indice può quindi essere utilizzato per evidenziare la robustezza richiesta dal \textit{package}\ped{G}.\\
Contrariamente, un valore eccessivamente basso potrebbe essere segnale di un \textit{package}\ped{G} che fornisce poche funzionalità. Tale \textit{package}\ped{G} potrebbe essere scarsamente utile;
\item \textbf{Accoppiamento efferente}: indica il numero di classi interne al \textit{package}\ped{G} che dipendono da classi esterne ad esso.\\
Mantenendo un basso valore di tale indice, è possibile mantenere il \textit{package}\ped{G} in grado di garantire funzionalità di base indipendentemente dal resto del sistema.
\end{itemize}

\paragraph{Instabilità}
Metrica proposta da Robert C. Martin che si prefigge di misurare l'instabilità del \textit{package}\ped{G} del sistema.\\
La stabilità di un \textit{package}\ped{G} indica la possibilità di effettuare modifiche a tale \textit{package}\ped{G} senza influenzarne altri all'interno dell'applicazione. Tale indice è strettamente legato all'accoppiamento efferente ed afferente e viene calcolato dalla seguente formula:
\begin{center}
$I = \frac{C_e}{C_a+C_e}$
\end{center}
dove:
\begin{itemize}
\item \textbf{$C_e$}: accoppiamento efferente;
\item \textbf{$C_a$}: accoppiamento afferente.
\end{itemize}
\textbf{Parametri utilizzati}:
\begin{itemize}
\item Range-accettazione: $[0.0-0.8]$;
\item Range-ottimale: $[0.0-0.3]$.
\end{itemize}

\paragraph{Copertura del codice}
Indica la percentuale di istruzioni che sono eseguite durante i test.\\
Maggiore è la percentuale di istruzioni coperte dai test eseguiti, maggiore sarà la probabilità che le componenti testate abbiano una ridotta quantità di errori.\\
Il valore di tale indice può essere abbassato da metodi molto semplici che non richiedono testing. Esempi di questi metodi sono: get e set.\\
\textbf{Parametri utilizzati}:
\begin{itemize}
\item Range-accettazione: $[42\%-100\%]$;
\item Range-ottimale: $[65\%-100\%]$.
\end{itemize}